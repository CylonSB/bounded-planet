use crate::networking::{id::ConnectionId, packets::Packet};
use quinn::{ConnectionError, crypto::rustls::TlsSession, generic::SendStream};
use tokio::sync::mpsc::UnboundedSender;

use super::{
    packets::StreamType,
    serialization::{RecvError, SendError}
};

use thiserror::Error;

#[derive(Debug, Error)]
pub enum NetworkError
{
    /// An error occurred in attempting to receive a packet from the given stream
    #[error("Unable to receive packet from connection {connection:?}. Underlying error: {err:?}")]
    ReceiveError {
        connection: ConnectionId,
        err: RecvError,
    },

    /// An error occurred during sending
    #[error("Unable to send packet on stream {stream:?} of connection {connection:?}. Underlying error: {err:?}")]
    SendError {
        connection: ConnectionId,
        stream: StreamType,
        err: SendError,
    },

    /// An error occurred attempting to send a packet through the MPSC to the async packet sender loop
    #[error("MPSC to packet sender closed for stream {stream:?} of connection {connection:?}. Packet that wasn't sent: {failed_packet:?}")]
    StreamSenderError {
        connection: ConnectionId,
        stream: Option<StreamType>,
        failed_packet: Packet,
    },

    /// An error occurred in quinn while attempting to connect
    #[error("Quinn connection error: {0:?}")]
    ConnectionError(#[from] quinn::ConnectionError)
}

/// An event generated by the network
#[derive(Debug)]
pub enum ReceiveEvent
{
    /// A new connection has opened
    Connected(ConnectionId, UnboundedSender<SendEvent>),

    /// A packet has arrived in a stream
    ReceivedPacket {
        connection: ConnectionId,
        data: Packet,
    },

    /// A connection has closed
    Disconnected(ConnectionId),

    /// The network socket has closed
    SocketClosed,

    /// An error occurred from the socket
    NetworkError(NetworkError),
}

/// An event to send to the network
#[derive(Debug, Clone)]
pub enum SendEvent
{
    /// Send a packet through a specific stream on a specific connection
    SendPacket {
        connection: ConnectionId,
        stream: StreamType,
        data: Packet,
    },

    /// Send a packet through a new stream which is created just for this packet.
    /// This should be used for very large packets.
    TransferPacket {
        connection: ConnectionId,
        data: Packet,
    }
}

impl SendEvent {
    /// Get the connectionid associated with this send event
    pub fn get_connection(&self) -> ConnectionId {
        match self {
            SendEvent::SendPacket { connection, .. } => *connection,
            SendEvent::TransferPacket { connection, .. } => *connection,
        }
    }

    /// Get a `NetworkError::StreamSenderError` from this send event 
    pub fn as_stream_sender_error(&self) -> NetworkError {
        let (c, s, f) = match self {
            SendEvent::SendPacket { connection, stream, data } => (*connection, Some(*stream), data),
            SendEvent::TransferPacket { connection, data } => (*connection, None, data)
        };

        NetworkError::StreamSenderError {
            connection: c,
            stream: s,
            failed_packet: f.clone()
        }
    }

    /// Send this event through the given quinn connection, looking for open streams in the `senders` vec
    pub async fn send(&self, senders: &mut Vec<SendStream<TlsSession>>, quinn_conn: &mut quinn::Connection) -> Result<(), NetworkError> {

        match self {
            SendEvent::SendPacket { stream, data, connection } => {
                // Find (or create) the sender for this stream
                let sender = match Self::get_stream_sender(&stream, senders, quinn_conn).await {
                    Ok(sender) => sender,
                    Err(err) => return Err(NetworkError::ConnectionError(err))
                };

                // Send the packet through the stream
                if let Err(err) = data.send(sender).await {
                    return Err(NetworkError::SendError {
                        connection: *connection,
                        stream: *stream,
                        err,
                    });
                }

                Ok(())
            }

            SendEvent::TransferPacket { data, .. } => {
                // Open a new stream for this transfer
                let uni = match quinn_conn.open_uni().await {
                    Ok(uni) => uni,
                    Err(err) => return Err(NetworkError::ConnectionError(err))
                };

                // Start sending the data
                tokio::spawn(Self::send_transfer(uni, data.clone()));

                Ok(())
            }
        }

    }

    async fn send_transfer(mut sender: SendStream<TlsSession>, data: Packet) {
        // Both of these method generate a result which is discarded.
        // Results from transfers are not sent anywhere as that could potentially result in
        // errors from a connection arriving in the ECS after is has closed!
        let _ = data.send(&mut sender).await;
        let _ = sender.finish().await;
    }

    async fn get_stream_sender<'a>(
        stream_type: &StreamType,
        stream_lookup: &'a mut Vec<SendStream<TlsSession>>,
        conn: &mut quinn::Connection
    ) -> Result<&'a mut SendStream<TlsSession>, ConnectionError>
    {
        // Calculate the index of this sender simply as the enum variant index
        let idx = *stream_type as usize;

        // Keep opening streams until the list of senders is large enough
        if idx >= stream_lookup.len() {
            stream_lookup.reserve(idx - stream_lookup.len() + 1);
        }
        while idx >= stream_lookup.len() {
            stream_lookup.push(conn.open_uni().await?);
        }

        // The list is now large enough that the sender definitely exists
        Ok(stream_lookup.get_mut(idx).expect("List was just grown to this size"))
    }
}
